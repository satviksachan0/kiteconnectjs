/**
 * strategy_core.ts
 *
 * This module provides a TypeScript implementation of an enhanced trading
 * strategy that combines a trend‑filtered volatility breakout system
 * with a Bollinger band mean‑reversion component.  It exposes
 * functions to compute technical indicators on an array of OHLC data,
 * generate trade signals, compute simplified option profits and
 * aggregate trade statistics.  The code is standalone and does not
 * perform any file I/O; you supply arrays of candle objects and get
 * back arrays of trade objects or summary statistics.
 */

/**
 * Interface describing a single OHLC candle with optional indicator fields.
 */
export interface Candle {
  datetime?: Date | string;
  open: number;
  high: number;
  low: number;
  close: number;
  // Indicator fields (optional)
  RSI?: number;
  ATR?: number;
  BB_mid?: number;
  BB_upper?: number;
  BB_lower?: number;
  [key: string]: any;
}

/**
 * Interface describing a trade generated by the strategy.
 */
export interface Trade {
  entryIndex: number;
  exitIndex: number;
  direction: "long" | "short";
  profit: number;
}

/**
 * Compute technical indicators used by the strategy.
 *
 * Adds RSI (14‑period), several simple moving averages (SMAs), Bollinger bands
 * (mid, upper, lower) and a 14‑period ATR to each candle in the provided
 * array.  Rolling values are back‑filled to avoid undefined entries.
 *
 * @param data An array of Candle objects containing at least high/low/close.
 * @returns The same array with additional indicator fields set.
 */
export function computeIndicators(data: Candle[]): Candle[] {
  // Calculate price differences for RSI
  const delta: number[] = [];
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      delta.push(0);
    } else {
      delta.push(data[i].close - data[i - 1].close);
    }
  }
  // Separate gains and losses
  const gains = delta.map((d) => (d > 0 ? d : 0));
  const losses = delta.map((d) => (d < 0 ? -d : 0));
  // Rolling averages for RSI
  const rsi: number[] = new Array(data.length).fill(NaN);
  for (let i = 0; i < data.length; i++) {
    if (i < 14) {
      rsi[i] = NaN;
      continue;
    }
    const avgGain = average(gains.slice(i - 13, i + 1));
    const avgLoss = average(losses.slice(i - 13, i + 1));
    const rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
    rsi[i] = 100 - 100 / (1 + rs);
  }

  // Compute SMAs for selected periods
  const periods = [5, 10, 20, 50, 100, 200];
  const sma: { [key: string]: number[] } = {};
  periods.forEach((p) => {
    sma[p] = new Array(data.length).fill(NaN);
    for (let i = 0; i < data.length; i++) {
      if (i + 1 < p) {
        sma[p][i] = NaN;
      } else {
        sma[p][i] = average(data.slice(i - p + 1, i + 1).map((c) => c.close));
      }
    }
  });

  // Bollinger bands (20‑period SMA ± 2 std dev)
  const bbMid: number[] = new Array(data.length).fill(NaN);
  const bbUpper: number[] = new Array(data.length).fill(NaN);
  const bbLower: number[] = new Array(data.length).fill(NaN);
  for (let i = 0; i < data.length; i++) {
    const window = 20;
    if (i + 1 < window) {
      continue;
    }
    const slice = data.slice(i - window + 1, i + 1).map((c) => c.close);
    const mean = average(slice);
    const stdDev = std(slice);
    bbMid[i] = mean;
    bbUpper[i] = mean + 2 * stdDev;
    bbLower[i] = mean - 2 * stdDev;
  }

  // True Range and ATR (14‑period)
  const tr: number[] = new Array(data.length).fill(0);
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      tr[i] = data[i].high - data[i].low;
    } else {
      const highLow = data[i].high - data[i].low;
      const highClose = Math.abs(data[i].high - data[i - 1].close);
      const lowClose = Math.abs(data[i].low - data[i - 1].close);
      tr[i] = Math.max(highLow, highClose, lowClose);
    }
  }
  const atr: number[] = new Array(data.length).fill(NaN);
  for (let i = 0; i < data.length; i++) {
    if (i + 1 < 14) continue;
    atr[i] = average(tr.slice(i - 13, i + 1));
  }

  // Populate indicator fields on the data array, backfilling NaNs
  for (let i = data.length - 1; i >= 0; i--) {
    // RSI
    if (!isNaN(rsi[i])) {
      data[i].RSI = rsi[i];
    } else if (i + 1 < data.length && data[i + 1].RSI !== undefined) {
      data[i].RSI = data[i + 1].RSI;
    }
    // ATR
    if (!isNaN(atr[i])) {
      data[i].ATR = atr[i];
    } else if (i + 1 < data.length && data[i + 1].ATR !== undefined) {
      data[i].ATR = data[i + 1].ATR;
    }
    // Bollinger bands
    if (!isNaN(bbMid[i])) {
      data[i].BB_mid = bbMid[i];
      data[i].BB_upper = bbUpper[i];
      data[i].BB_lower = bbLower[i];
    } else if (i + 1 < data.length && data[i + 1].BB_mid !== undefined) {
      data[i].BB_mid = data[i + 1].BB_mid;
      data[i].BB_upper = data[i + 1].BB_upper;
      data[i].BB_lower = data[i + 1].BB_lower;
    }
    // SMAs
    periods.forEach((p) => {
      const key = `SMA_${p}`;
      if (!isNaN(sma[p][i])) {
        data[i][key] = sma[p][i];
      } else if (i + 1 < data.length && data[i + 1][key] !== undefined) {
        data[i][key] = data[i + 1][key];
      }
    });
  }

  return data;
}

/**
 * Generate Bollinger band mean‑reversion trades.
 *
 * A long trade is initiated when the closing price dips below the lower
 * Bollinger band; a short trade is initiated when it rises above the
 * upper band.  The position is closed when the close crosses the band
 * midpoint or after three bars, whichever comes first.
 *
 * @param data Array of candles with Bollinger bands computed.
 * @returns An array of trades capturing entry index, exit index, direction and profit.
 */
export function bollingerReversalSignals(data: Candle[]): Trade[] {
  const trades: Trade[] = [];
  for (let i = 1; i < data.length; i++) {
    const c = data[i];
    if (c.BB_mid === undefined || c.BB_lower === undefined || c.BB_upper === undefined) {
      continue;
    }
    // Long reversal
    if (c.close < c.BB_lower) {
      let exitIndex: number | null = null;
      for (let j = i + 1; j < Math.min(i + 4, data.length); j++) {
        if (data[j].close >= (data[j].BB_mid ?? 0)) {
          exitIndex = j;
          break;
        }
      }
      if (exitIndex === null) {
        exitIndex = Math.min(i + 3, data.length - 1);
      }
      const entryPrice = c.close;
      const exitPrice = data[exitIndex].close;
      trades.push({
        entryIndex: i,
        exitIndex,
        direction: "long",
        profit: exitPrice - entryPrice,
      });
    }
    // Short reversal
    if (c.close > c.BB_upper) {
      let exitIndex: number | null = null;
      for (let j = i + 1; j < Math.min(i + 4, data.length); j++) {
        if (data[j].close <= (data[j].BB_mid ?? 0)) {
          exitIndex = j;
          break;
        }
      }
      if (exitIndex === null) {
        exitIndex = Math.min(i + 3, data.length - 1);
      }
      const entryPrice = c.close;
      const exitPrice = data[exitIndex].close;
      trades.push({
        entryIndex: i,
        exitIndex,
        direction: "short",
        profit: entryPrice - exitPrice,
      });
    }
  }
  return trades;
}

/**
 * Generate trend‑filtered volatility breakout trades.
 *
 * A breakout occurs when the current high exceeds the previous high by at
 * least half an ATR in an uptrend, or when the current low falls below
 * the previous low by half an ATR in a downtrend.  The trade is
 * conditioned on the SMA trend: a rising SMA above the close for longs
 * and a falling SMA below the close for shorts.  Exits occur at a
 * profit target (targetMul × ATR), a stop loss (stopMul × ATR) or
 * after four bars.
 *
 * @param data Array of candles with ATR and SMA fields computed.
 * @param smaPeriod SMA period used to determine the trend (default 50).
 * @param targetMul Profit target multiple of ATR (default 0.5).
 * @param stopMul Stop loss multiple of ATR (default 1.5).
 * @returns An array of trades representing the breakout signals.
 */
export function trendFilteredBreakouts(
  data: Candle[],
  smaPeriod: number = 50,
  targetMul: number = 0.5,
  stopMul: number = 1.5
): Trade[] {
  const trades: Trade[] = [];
  const smaKey = `SMA_${smaPeriod}`;

  for (let i = 1; i < data.length; i++) {
    const prev = data[i - 1];
    const curr = data[i];
    const smaCurr = curr[smaKey];
    const smaPrev = prev[smaKey];
    if (smaCurr === undefined || smaPrev === undefined) {
      continue;
    }
    const atr = curr.ATR ?? 0;

    // Long breakout condition
    const longTrigger =
      curr.high > prev.high + 0.5 * atr && curr.close > smaCurr && smaCurr > smaPrev;
    if (longTrigger) {
      const entryPrice = curr.close;
      const stop = entryPrice - stopMul * atr;
      const target = entryPrice + targetMul * atr;
      let exited = false;
      for (let j = i + 1; j < Math.min(i + 5, data.length); j++) {
        if (data[j].low < stop) {
          trades.push({
            entryIndex: i,
            exitIndex: j,
            direction: "long",
            profit: stop - entryPrice,
          });
          exited = true;
          break;
        }
        if (data[j].high > target) {
          trades.push({
            entryIndex: i,
            exitIndex: j,
            direction: "long",
            profit: target - entryPrice,
          });
          exited = true;
          break;
        }
      }
      if (!exited) {
        const exitIndex = Math.min(i + 4, data.length - 1);
        const exitPrice = data[exitIndex].close;
        trades.push({
          entryIndex: i,
          exitIndex,
          direction: "long",
          profit: exitPrice - entryPrice,
        });
      }
    }

    // Short breakout condition
    const shortTrigger =
      curr.low < prev.low - 0.5 * atr && curr.close < smaCurr && smaCurr < smaPrev;
    if (shortTrigger) {
      const entryPrice = curr.close;
      const stop = entryPrice + stopMul * atr;
      const target = entryPrice - targetMul * atr;
      let exited = false;
      for (let j = i + 1; j < Math.min(i + 5, data.length); j++) {
        if (data[j].high > stop) {
          trades.push({
            entryIndex: i,
            exitIndex: j,
            direction: "short",
            profit: entryPrice - stop,
          });
          exited = true;
          break;
        }
        if (data[j].low < target) {
          trades.push({
            entryIndex: i,
            exitIndex: j,
            direction: "short",
            profit: entryPrice - target,
          });
          exited = true;
          break;
        }
      }
      if (!exited) {
        const exitIndex = Math.min(i + 4, data.length - 1);
        const exitPrice = data[exitIndex].close;
        trades.push({
          entryIndex: i,
          exitIndex,
          direction: "short",
          profit: entryPrice - exitPrice,
        });
      }
    }
  }

  return trades;
}

/**
 * Compute option profits based on intrinsic value changes only.
 *
 * For each trade, a call or put option is purchased with a strike
 * offset by 10 points from the underlying close at entry.  A long
 * trade buys a call (strike is 10 points below the entry close) and
 * assumes the option is filled at the day's low.  A short trade buys
 * a put (strike 10 points above) filled at the day's high.  Profits
 * are calculated as the change in intrinsic value from entry to exit.
 * Time value and premiums are ignored.
 *
 * @param trades Array of trades with entry and exit indices.
 * @param data Array of candles from which high, low and close prices are read.
 * @returns Array of numeric profits corresponding to each trade.
 */
export function computeOptionProfits(trades: Trade[], data: Candle[]): number[] {
  return trades.map((t) => {
    const entryIdx = t.entryIndex;
    const exitIdx = t.exitIndex;
    const direction = t.direction;
    if (direction === "long") {
      const strike = data[entryIdx].close - 10;
      const entryUnderlying = data[entryIdx].low;
      const exitUnderlying = data[exitIdx].close;
      const entryIntrinsic = Math.max(entryUnderlying - strike, 0);
      const exitIntrinsic = Math.max(exitUnderlying - strike, 0);
      return exitIntrinsic - entryIntrinsic;
    } else {
      const strike = data[entryIdx].close + 10;
      const entryUnderlying = data[entryIdx].high;
      const exitUnderlying = data[exitIdx].close;
      const entryIntrinsic = Math.max(strike - entryUnderlying, 0);
      const exitIntrinsic = Math.max(strike - exitUnderlying, 0);
      return exitIntrinsic - entryIntrinsic;
    }
  });
}

/**
 * Summarise an array of trades with basic statistics.
 *
 * Returns the number of trades, number of winners, number of losers,
 * win rate and total P&L.  If no trades are provided, all values
 * default to zero.
 *
 * @param trades Array of trade objects.
 */
export function summarizeTrades(trades: Trade[]) {
  const nTrades = trades.length;
  if (nTrades === 0) {
    return {
      nTrades: 0,
      wins: 0,
      losses: 0,
      winRate: 0,
      totalProfit: 0,
    };
  }
  const wins = trades.filter((t) => t.profit > 0).length;
  const totalProfit = trades.reduce((acc, t) => acc + t.profit, 0);
  return {
    nTrades,
    wins,
    losses: nTrades - wins,
    winRate: wins / nTrades,
    totalProfit,
  };
}

/* Utility functions */

/**
 * Compute the arithmetic mean of an array of numbers.
 */
function average(arr: number[]): number {
  if (arr.length === 0) return NaN;
  return arr.reduce((acc, val) => acc + val, 0) / arr.length;
}

/**
 * Compute the sample standard deviation of an array of numbers.
 */
function std(arr: number[]): number {
  const mean = average(arr);
  const variance = average(arr.map((x) => (x - mean) ** 2));
  return Math.sqrt(variance);
}

